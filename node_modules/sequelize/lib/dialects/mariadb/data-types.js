'use strict';

const _ = require('lodash');
const moment = require('moment-timezone');

module.exports = BaseTypes => {
  BaseTypes.ABSTRACT.prototype.dialectTypes = 'https://mariadb.com/kb/en/library/resultset/#field-types';

  /**
   * types: [buffer_type, ...]
   * @see documentation : https://mariadb.com/kb/en/library/resultset/#field-types
   * @see connector implementation : https://github.com/MariaDB/mariadb-connector-nodejs/blob/master/lib/const/field-type.js
   */

  BaseTypes.DATE.types.mariadb = ['DATETIME'];
  BaseTypes.STRING.types.mariadb = ['VAR_STRING'];
  BaseTypes.CHAR.types.mariadb = ['STRING'];
  BaseTypes.TEXT.types.mariadb = ['BLOB'];
  BaseTypes.TINYINT.types.mariadb = ['TINY'];
  BaseTypes.SMALLINT.types.mariadb = ['SHORT'];
  BaseTypes.MEDIUMINT.types.mariadb = ['INT24'];
  BaseTypes.INTEGER.types.mariadb = ['LONG'];
  BaseTypes.BIGINT.types.mariadb = ['LONGLONG'];
  BaseTypes.FLOAT.types.mariadb = ['FLOAT'];
  BaseTypes.TIME.types.mariadb = ['TIME'];
  BaseTypes.DATEONLY.types.mariadb = ['DATE'];
  BaseTypes.BOOLEAN.types.mariadb = ['TINY'];
  BaseTypes.BLOB.types.mariadb = ['TINYBLOB', 'BLOB', 'LONGBLOB'];
  BaseTypes.DECIMAL.types.mariadb = ['NEWDECIMAL'];
  BaseTypes.UUID.types.mariadb = false;
  BaseTypes.ENUM.types.mariadb = false;
  BaseTypes.REAL.types.mariadb = ['DOUBLE'];
  BaseTypes.DOUBLE.types.mariadb = ['DOUBLE'];
  BaseTypes.GEOMETRY.types.mariadb = ['GEOMETRY'];
  BaseTypes.JSON.types.mariadb = ['JSON'];

<<<<<<< HEAD
=======
=======
"use strict";
const wkx = require("wkx");
const _ = require("lodash");
const momentTz = require("moment-timezone");
const moment = require("moment");
module.exports = (BaseTypes) => {
  BaseTypes.ABSTRACT.prototype.dialectTypes = "https://mariadb.com/kb/en/library/resultset/#field-types";
  BaseTypes.DATE.types.mariadb = ["DATETIME"];
  BaseTypes.STRING.types.mariadb = ["VAR_STRING"];
  BaseTypes.CHAR.types.mariadb = ["STRING"];
  BaseTypes.TEXT.types.mariadb = ["BLOB"];
  BaseTypes.TINYINT.types.mariadb = ["TINY"];
  BaseTypes.SMALLINT.types.mariadb = ["SHORT"];
  BaseTypes.MEDIUMINT.types.mariadb = ["INT24"];
  BaseTypes.INTEGER.types.mariadb = ["LONG"];
  BaseTypes.BIGINT.types.mariadb = ["LONGLONG"];
  BaseTypes.FLOAT.types.mariadb = ["FLOAT"];
  BaseTypes.TIME.types.mariadb = ["TIME"];
  BaseTypes.DATEONLY.types.mariadb = ["DATE"];
  BaseTypes.BOOLEAN.types.mariadb = ["TINY"];
  BaseTypes.BLOB.types.mariadb = ["TINYBLOB", "BLOB", "LONGBLOB"];
  BaseTypes.DECIMAL.types.mariadb = ["NEWDECIMAL"];
  BaseTypes.UUID.types.mariadb = false;
  BaseTypes.ENUM.types.mariadb = false;
  BaseTypes.REAL.types.mariadb = ["DOUBLE"];
  BaseTypes.DOUBLE.types.mariadb = ["DOUBLE"];
  BaseTypes.GEOMETRY.types.mariadb = ["GEOMETRY"];
  BaseTypes.JSON.types.mariadb = ["JSON"];
>>>>>>> 84d756422dd9b4a83e20a772b23d90cf7d03fa01
>>>>>>> f815c2529adf4832ab14aea8db2187453ed14843
  class DECIMAL extends BaseTypes.DECIMAL {
    toSql() {
      let definition = super.toSql();
      if (this._unsigned) {
        definition += ' UNSIGNED';
      }
      if (this._zerofill) {
        definition += ' ZEROFILL';
<<<<<<< HEAD
=======
=======
        definition += " UNSIGNED";
      }
      if (this._zerofill) {
        definition += " ZEROFILL";
>>>>>>> 84d756422dd9b4a83e20a772b23d90cf7d03fa01
>>>>>>> f815c2529adf4832ab14aea8db2187453ed14843
      }
      return definition;
    }
  }

  class DATE extends BaseTypes.DATE {
    toSql() {
      return `DATETIME${this._length ? `(${this._length})` : ''}`;
    }
    _stringify(date, options) {
      date = this._applyTimezone(date, options);
      return date.format('YYYY-MM-DD HH:mm:ss.SSS');
<<<<<<< HEAD
=======
=======
  class DATE extends BaseTypes.DATE {
    toSql() {
      return this._length ? `DATETIME(${this._length})` : "DATETIME";
    }
    _stringify(date, options) {
      if (!moment.isMoment(date)) {
        date = this._applyTimezone(date, options);
      }
      return date.format("YYYY-MM-DD HH:mm:ss.SSS");
>>>>>>> 84d756422dd9b4a83e20a772b23d90cf7d03fa01
>>>>>>> f815c2529adf4832ab14aea8db2187453ed14843
    }
    static parse(value, options) {
      value = value.string();
      if (value === null) {
        return value;
      }
      if (moment.tz.zone(options.timezone)) {
        value = moment.tz(value, options.timezone).toDate();
      }
      else {
<<<<<<< HEAD
=======
=======
      if (momentTz.tz.zone(options.timezone)) {
        value = momentTz.tz(value, options.timezone).toDate();
      } else {
>>>>>>> 84d756422dd9b4a83e20a772b23d90cf7d03fa01
>>>>>>> f815c2529adf4832ab14aea8db2187453ed14843
        value = new Date(`${value} ${options.timezone}`);
      }
      return value;
    }
  }

<<<<<<< HEAD
=======
=======
>>>>>>> 84d756422dd9b4a83e20a772b23d90cf7d03fa01
>>>>>>> f815c2529adf4832ab14aea8db2187453ed14843
  class DATEONLY extends BaseTypes.DATEONLY {
    static parse(value) {
      return value.string();
    }
  }

  class UUID extends BaseTypes.UUID {
    toSql() {
      return 'CHAR(36) BINARY';
    }
  }

<<<<<<< HEAD
=======
=======
  class UUID extends BaseTypes.UUID {
    toSql() {
      return "CHAR(36) BINARY";
    }
  }
>>>>>>> 84d756422dd9b4a83e20a772b23d90cf7d03fa01
>>>>>>> f815c2529adf4832ab14aea8db2187453ed14843
  class GEOMETRY extends BaseTypes.GEOMETRY {
    constructor(type, srid) {
      super(type, srid);
      if (_.isEmpty(this.type)) {
        this.sqlType = this.key;
      }
      else {
        this.sqlType = this.type;
      }
    }
<<<<<<< HEAD
=======
=======
      } else {
        this.sqlType = this.type;
      }
    }
    static parse(value) {
      value = value.buffer();
      if (!value || value.length === 0) {
        return null;
      }
      value = value.slice(4);
      return wkx.Geometry.parse(value).toGeoJSON({ shortCrs: true });
    }
>>>>>>> 84d756422dd9b4a83e20a772b23d90cf7d03fa01
>>>>>>> f815c2529adf4832ab14aea8db2187453ed14843
    toSql() {
      return this.sqlType;
    }
  }

  class ENUM extends BaseTypes.ENUM {
    toSql(options) {
      return `ENUM(${this.values.map(value => options.escape(value)).join(', ')})`;
    }
  }

  class JSONTYPE extends BaseTypes.JSON {
    _stringify(value, options) {
      return options.operation === 'where' && typeof value === 'string' ? value
        : JSON.stringify(value);
    }
  }

<<<<<<< HEAD
=======
=======
  class ENUM extends BaseTypes.ENUM {
    toSql(options) {
      return `ENUM(${this.values.map((value) => options.escape(value)).join(", ")})`;
    }
  }
  class JSONTYPE extends BaseTypes.JSON {
    _stringify(value, options) {
      return options.operation === "where" && typeof value === "string" ? value : JSON.stringify(value);
    }
  }
>>>>>>> 84d756422dd9b4a83e20a772b23d90cf7d03fa01
>>>>>>> f815c2529adf4832ab14aea8db2187453ed14843
  return {
    ENUM,
    DATE,
    DATEONLY,
    UUID,
    GEOMETRY,
    DECIMAL,
    JSON: JSONTYPE
  };
};
<<<<<<< HEAD
=======
<<<<<<< HEAD
=======
//# sourceMappingURL=data-types.js.map
>>>>>>> 84d756422dd9b4a83e20a772b23d90cf7d03fa01
>>>>>>> f815c2529adf4832ab14aea8db2187453ed14843
